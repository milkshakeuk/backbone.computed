{"version":3,"sources":["backbone.computed.js"],"names":["root","factory","define","amd","_","Backbone","exports","require","this","toJSON","Model","prototype","get","extend","options","isSaving","has","call","hasComputed","computed","each","value","key","isFunction","attributes","attr","hasNonComputed"],"mappings":"CAEC,SAAUA,EAAMC,GAEf,GAAsB,kBAAXC,SAAyBA,OAAOC,IACzCD,QAAQ,aAAc,WAAY,WAAY,SAAUE,EAAGC,EAAUC,GACnEL,EAAQD,EAAMM,EAASF,EAAGC,SAIvB,IAAuB,mBAAZC,SAAyB,CACzC,GAAIF,GAAIG,QAAQ,cACZF,EAAWE,QAAQ,WACvBN,GAAQD,EAAMM,QAASF,EAAGC,OAK1BJ,GAAQD,KAAUA,EAAKI,EAAGJ,EAAKK,WAEhCG,KAAM,SAAUR,EAAMM,EAASF,EAAGC,GAGnC,GAAII,GAASJ,EAASK,MAAMC,UAAUF,OAClCG,EAAMP,EAASK,MAAMC,UAAUC,GAiDnC,OA/CAP,GAASK,MAAQL,EAASK,MAAMG,QAS9BJ,OAAQ,SAAUK,GAChB,GAAIC,GAAWX,EAAEY,IAAIF,EAAS,cAC9B,IAAIC,EAAU,MAAON,GAAOQ,KAAKT,KAAMM,EAEvC,IAAII,KAAgBV,KAAKW,SACrBA,IASJ,OAPID,IACFd,EAAEgB,KAAKZ,KAAKW,SAAU,SAAUE,EAAOC,GACrCH,EAASG,GAAOlB,EAAEmB,WAAWF,GAASA,EAAMJ,KAAKT,MAAQa,GACxDb,MAIEJ,EAAES,OAAOM,EAAUX,KAAKgB,aAWjCZ,IAAK,SAAUa,GACb,GAAIP,GAAcV,KAAKW,UAAYf,EAAEY,IAAIR,KAAKW,SAAUM,GACpDC,EAAiBtB,EAAEY,IAAIR,KAAKgB,WAAYC,EAE5C,IAAIP,IAAgBQ,EAAgB,CAClC,GAAIL,GAAQb,KAAKW,SAASM,EAC1B,OAAOrB,GAAEmB,WAAWF,GAASA,EAAMJ,KAAKT,MAAQa,EAGlD,MAAOT,GAAIK,KAAKT,KAAMiB,MAInBpB","file":"backbone.computed.min.js","sourcesContent":["/* global define, require */\r\n\r\n(function (root, factory) {\r\n  // Start with AMD support.\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(['underscore', 'backbone', 'exports'], function (_, Backbone, exports) {\r\n      factory(root, exports, _, Backbone);\r\n    });\r\n\r\n    // Next check for Node.js or CommonJS.\r\n  } else if (typeof exports !== 'undefined') {\r\n    var _ = require('underscore');\r\n    var Backbone = require('backbone');\r\n    factory(root, exports, _, Backbone);\r\n\r\n    // Finnaly, if none of the above, create the extension and\r\n    // assume Backbone is available at (browser) global scope.\r\n  } else {\r\n    factory(root, {}, root._, root.Backbone);\r\n  }\r\n} (this, function (root, exports, _, Backbone) {\r\n\r\n  // original implamentation of `toJSON` and `get`\r\n  var toJSON = Backbone.Model.prototype.toJSON;\r\n  var get = Backbone.Model.prototype.get;\r\n\r\n  Backbone.Model = Backbone.Model.extend({\r\n    /**\r\n     * Return a copy of the model's `attributes` object.\r\n     * When saving we dont want to pollute the attributes with computed\r\n     * properties but when serialising for use with the templates we do\r\n     *\r\n     * @param {Object} options Passed from Backbone.sync\r\n     * @returns {Object} JSON copy of the model's `attributes` object\r\n     */\r\n    toJSON: function (options) {\r\n      var isSaving = _.has(options, 'emulateHTTP');\r\n      if (isSaving) return toJSON.call(this, options);\r\n\r\n      var hasComputed = !!this.computed;\r\n      var computed = {};\r\n\r\n      if (hasComputed) {\r\n        _.each(this.computed, function (value, key) {\r\n          computed[key] = _.isFunction(value) ? value.call(this) : value;\r\n        }, this);\r\n      }\r\n\r\n      // ensure non-computed property wins in property clash\r\n      return _.extend(computed, this.attributes);\r\n    },\r\n\r\n    /**\r\n     * Get the value of an attribute or computed property.\r\n     * If we have a computed and non-computed property clash then the non-computed\r\n     * value should be returned\r\n     *\r\n     * @param {String} attr Name of model property\r\n     * @returns Value of computed property or model attribute\r\n     */\r\n    get: function (attr) {\r\n      var hasComputed = this.computed && _.has(this.computed, attr);\r\n      var hasNonComputed = _.has(this.attributes, attr);\r\n\r\n      if (hasComputed && !hasNonComputed) {\r\n        var value = this.computed[attr];\r\n        return _.isFunction(value) ? value.call(this) : value;\r\n      }\r\n\r\n      return get.call(this, attr);\r\n    }\r\n  });\r\n\r\n  return Backbone;\r\n\r\n}));"],"sourceRoot":"/source/"}